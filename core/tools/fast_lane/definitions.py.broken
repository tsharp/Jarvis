from pydantic import BaseModel, Field
from typing import Any, Dict, List, Optional
import os
from pathlib import Path
# Import relative to package if possible, or absolute
try:
    from core.tools.fast_lane.security import SecurePathValidator
except ImportError:
    # If running standalone/testing
    from .security import SecurePathValidator

class BaseNativeTool(BaseModel):
    """Base class for Native Fast Lane Tools."""
    pass

class HomeReadTool(BaseNativeTool):
    """Reads a file from the TRION home directory."""
    path: str = Field(..., description="Path to the file to read, relative to TRION home.")
    
    def execute(self) -> str:
        validator = SecurePathValidator()
        is_valid, resolved, error = validator.validate(self.path)
        if not is_valid:
            raise ValueError(error)
            
        with open(resolved, 'r', encoding='utf-8') as f:
            return f.read()

class HomeWriteTool(BaseNativeTool):
    """Writes content to a file in the TRION home directory."""
    path: str = Field(..., description="Path to the file to write, relative to TRION home.")
    content: str = Field(..., description="Content to write to the file.")
    overwrite: bool = Field(False, description="Whether to overwrite existing files.")
    
    def execute(self) -> str:
        validator = SecurePathValidator()
        is_valid, resolved, error = validator.validate(self.path)
        if not is_valid:
            raise ValueError(error)
            
        if os.path.exists(resolved) and not self.overwrite:
            raise FileExistsError(f"File {self.path} already exists and overwrite is False.")
            
        # Ensure parent directory exists
        os.makedirs(os.path.dirname(resolved), exist_ok=True)
        
        with open(resolved, 'w', encoding='utf-8') as f:
            f.write(self.content)
            
        return f"File written successfully to {self.path}"

class HomeListTool(BaseNativeTool):
    """Lists files in a directory in the TRION home directory."""
    path: str = Field(".", description="Directory to list, relative to TRION home.")
    recursive: bool = Field(False, description="List recursively if True.")
    
    def execute(self) -> List[str]:
        validator = SecurePathValidator()
        is_valid, resolved, error = validator.validate(self.path)
        if not is_valid:
             raise ValueError(error)
             
        if not os.path.isdir(resolved):
            raise NotADirectoryError(f"Path {self.path} is not a directory.")
            
        results = []
        base_path = Path(resolved)
        
        def _scan(p: Path):
            for item in p.iterdir():
                if item.is_dir():
                    if self.recursive:
                         _scan(item)
                    results.append(str(item.relative_to(base_path)) + "/")
                else:
                    results.append(str(item.relative_to(base_path)))
        
        # Simple iterative approach for recursive listing to avoid recursion depth issues
        # Actually os.walk is better
        if self.recursive:
            for root, dirs, files in os.walk(resolved):
                root_path = Path(root)
                for d in dirs:
                     results.append(str((root_path / d).relative_to(base_path)) + "/")
                for f in files:
                     results.append(str((root_path / f).relative_to(base_path)))
        else:
            for item in base_path.iterdir():
                 if item.is_dir():
                      results.append(item.name + "/")
                 else:
                      results.append(item.name)
                
        return sorted(results)


        {
            "name": "home_write",
            "mcp": "fast-lane",
            "description": "Writes content to a file in the TRION home directory. FAST execution.",
            "arguments": "path (str), content (str), overwrite (bool)"
        },
         {
            "name": "home_list",
            "mcp": "fast-lane",
            "description": "Lists contents of a directory in the TRION home. FAST execution.",
            "arguments": "path (str), recursive (bool)"
        },
        {
            "name": "memory_save",
            "mcp": "fast-lane",
            "description": "Save memory to database (text-only, embeddings computed async). FAST execution.",
            "arguments": "content (str), role (str), conversation_id (str)"
        },
        {
            "name": "memory_search",
            "mcp": "fast-lane",
            "description": "Search memory using FTS keyword search. FAST execution.",
            "arguments": "query (str), limit (int), conversation_id (str)"
        },
        {
            "name": "workspace_save",
            "mcp": "fast-lane",
            "description": "Save workspace event to database. FAST execution.",
            "arguments": "event_type (str), event_data (dict), conversation_id (str)"
        },
        {
            "name": "workspace_list",
            "mcp": "fast-lane",
            "description": "List active workspace events (last 48h). FAST execution.",
            "arguments": "conversation_id (str), event_type (str), limit (int)"
        }
    ]
# ==============================================================================
# MEMORY & WORKSPACE TOOLS (Fast Lane - Direct SQLite Access)
# ==============================================================================

import sqlite3
from datetime import datetime
from typing import List, Optional
import json

def get_db_connection():
    """
    Get SQLite connection to memory.db with WAL mode
    
    Path: /app/memory_data/memory.db (mounted volume)
    """
    conn = sqlite3.connect(
        '/app/memory_data/memory.db',
        timeout=5.0,  # 5s timeout for locks
        check_same_thread=False
    )
    conn.row_factory = sqlite3.Row
    return conn


class MemorySaveTool(BaseNativeTool):
    """
    Saves memory text to database (embeddings computed async by Slow Lane).
    
    Fast Lane: TEXT-ONLY insert (<50ms)
    Slow Lane: Will compute embeddings later for semantic search
    """
    content: str = Field(..., description="Content to save to memory")
    role: str = Field("user", description="Role: user or assistant")
    conversation_id: str = Field(..., description="Conversation ID")
    
    def execute(self) -> str:
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(
                    """
                    INSERT INTO memory (conversation_id, role, content, created_at)
                    VALUES (?, ?, ?, ?)
                    """,
                    (self.conversation_id, self.role, self.content, datetime.utcnow().isoformat())
                )
                conn.commit()
                row_id = cursor.lastrowid
                
            return f"Memory saved (ID: {row_id}). Embeddings will be computed in background."
            
        except Exception as e:
            raise RuntimeError(f"Failed to save memory: {str(e)}")


class MemorySearchTool(BaseNativeTool):
    """
    Search memory using Full-Text Search (FTS).
    
    Fast Lane: Uses SQLite FTS for keyword search (<50ms)
    Note: Semantic search (embeddings) still goes through Slow Lane
    """
    query: str = Field(..., description="Search query")
    limit: int = Field(5, description="Max results to return")
    conversation_id: Optional[str] = Field(None, description="Filter by conversation ID")
    
    def execute(self) -> List[str]:
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Check if FTS table exists
                cursor.execute(
                    "SELECT name FROM sqlite_master WHERE type='table' AND name='memory_fts'"
                )
                has_fts = cursor.fetchone() is not None
                
                if has_fts:
                    # Use FTS for fast keyword search
                    if self.conversation_id:
                        cursor.execute(
                            """
                            SELECT m.content, m.role, m.created_at
                            FROM memory m
                            JOIN memory_fts fts ON m.rowid = fts.rowid
                            WHERE memory_fts MATCH ? AND m.conversation_id = ?
                            ORDER BY rank
                            LIMIT ?
                            """,
                            (self.query, self.conversation_id, self.limit)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT m.content, m.role, m.created_at
                            FROM memory m
                            JOIN memory_fts fts ON m.rowid = fts.rowid
                            WHERE memory_fts MATCH ?
                            ORDER BY rank
                            LIMIT ?
                            """,
                            (self.query, self.limit)
                        )
                else:
                    # Fallback: Simple LIKE search
                    if self.conversation_id:
                        cursor.execute(
                            """
                            SELECT content, role, created_at
                            FROM memory
                            WHERE content LIKE ? AND conversation_id = ?
                            ORDER BY created_at DESC
                            LIMIT ?
                            """,
                            (f"%{self.query}%", self.conversation_id, self.limit)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT content, role, created_at
                            FROM memory
                            WHERE content LIKE ?
                            ORDER BY created_at DESC
                            LIMIT ?
                            """,
                            (f"%{self.query}%", self.limit)
                        )
                
                results = cursor.fetchall()
                
            # Format results
            if not results:
                return []
            
            return [
                f"[{row['role']}] {row['content'][:200]}..." if len(row['content']) > 200 
                else f"[{row['role']}] {row['content']}"
                for row in results
            ]
            
        except Exception as e:
            raise RuntimeError(f"Failed to search memory: {str(e)}")


class WorkspaceSaveTool(BaseNativeTool):
    """
    Saves workspace event to database.
    
    Fast Lane: Direct SQLite insert (<50ms)
    """
    event_type: str = Field(..., description="Event type: container_started, task_started, etc.")
    event_data: dict = Field(..., description="Event data as dict")
    conversation_id: str = Field(..., description="Conversation ID")
    
    def execute(self) -> str:
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Check if workspace_events table exists, create if not
                cursor.execute(
                    """
                    CREATE TABLE IF NOT EXISTS workspace_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        conversation_id TEXT NOT NULL,
                        event_type TEXT NOT NULL,
                        event_data TEXT NOT NULL,
                        created_at TEXT NOT NULL
                    )
                    """
                )
                
                cursor.execute(
                    """
                    INSERT INTO workspace_events (conversation_id, event_type, event_data, created_at)
                    VALUES (?, ?, ?, ?)
                    """,
                    (
                        self.conversation_id,
                        self.event_type,
                        json.dumps(self.event_data),
                        datetime.utcnow().isoformat()
                    )
                )
                conn.commit()
                event_id = cursor.lastrowid
                
            return f"Workspace event saved (ID: {event_id}, Type: {self.event_type})"
            
        except Exception as e:
            raise RuntimeError(f"Failed to save workspace event: {str(e)}")


class WorkspaceListTool(BaseNativeTool):
    """
    Lists active workspace events (last 48 hours).
    
    Fast Lane: Direct SQLite query (<50ms)
    """
    conversation_id: Optional[str] = Field(None, description="Filter by conversation ID")
    event_type: Optional[str] = Field(None, description="Filter by event type")
    limit: int = Field(10, description="Max events to return")
    
    def execute(self) -> List[dict]:
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Build query with filters
                query = """
                    SELECT id, conversation_id, event_type, event_data, created_at
                    FROM workspace_events
                    WHERE created_at >= datetime('now', '-2 days')
                """
                params = []
                
                if self.conversation_id:
                    query += " AND conversation_id = ?"
                    params.append(self.conversation_id)
                
                if self.event_type:
                    query += " AND event_type = ?"
                    params.append(self.event_type)
                
                query += " ORDER BY created_at DESC LIMIT ?"
                params.append(self.limit)
                
                cursor.execute(query, params)
                results = cursor.fetchall()
            
            # Format results
            return [
                {
                    "id": row['id'],
                    "conversation_id": row['conversation_id'],
                    "event_type": row['event_type'],
                    "event_data": json.loads(row['event_data']),
                    "created_at": row['created_at']
                }
                for row in results
            ]
            
        except Exception as e:
            raise RuntimeError(f"Failed to list workspace events: {str(e)}")


# ==============================================================================
# TOOL REGISTRY
# ==============================================================================

# Map of tool names to classes
NATIVE_TOOLS = {
    "home_read": HomeReadTool,
    "home_write": HomeWriteTool,
    "home_list": HomeListTool,
    "memory_save": MemorySaveTool,
    "memory_search": MemorySearchTool,
    "workspace_save": WorkspaceSaveTool,
    "workspace_list": WorkspaceListTool,
}

def get_native_tool_class(name: str):
    return NATIVE_TOOLS.get(name)

def get_fast_lane_tools_summary() -> List[Dict[str, Any]]:
    """Returns tool definitions for MCP Registry (Simplified Format)."""
    return [
        {
            "name": "home_read",
            "mcp": "fast-lane",
            "description": "Reads a file from the TRION home directory. FAST execution.",
            "arguments": "path (str)"
        },
        {
            "name": "home_write",
            "mcp": "fast-lane",
            "description": "Writes content to a file in the TRION home directory. FAST execution.",
            "arguments": "path (str), content (str), overwrite (bool)"
        },
        {
            "name": "home_list",
            "mcp": "fast-lane",
            "description": "Lists contents of a directory in the TRION home. FAST execution.",
            "arguments": "path (str), recursive (bool)"
        },
        {
            "name": "memory_save",
            "mcp": "fast-lane",
            "description": "Save memory to database (text-only, embeddings computed async). FAST execution.",
            "arguments": "content (str), role (str), conversation_id (str)"
        },
        {
            "name": "memory_search",
            "mcp": "fast-lane",
            "description": "Search memory using FTS keyword search. FAST execution.",
            "arguments": "query (str), limit (int), conversation_id (str)"
        },
        {
            "name": "workspace_save",
            "mcp": "fast-lane",
            "description": "Save workspace event to database. FAST execution.",
            "arguments": "event_type (str), event_data (dict), conversation_id (str)"
        },
        {
            "name": "workspace_list",
            "mcp": "fast-lane",
            "description": "List active workspace events (last 48h). FAST execution.",
            "arguments": "conversation_id (str), event_type (str), limit (int)"
        }
    ]
